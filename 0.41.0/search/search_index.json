{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Trading Toolbox</p> <p>A Python library providing essential tools for traders to manage and interact with financial market data. This library consists of three main modules: exchange kline download, database management, and general utilities.</p> <p>Attributes:</p> <ul> <li>clickhouse: Functions for database-related operations.</li> <li>exchanges: Functions to download and manage OHLCV data.</li> <li>utils : Utility functions for time manipulation, logging, and other tasks.</li> </ul>"},{"location":"#example","title":"Example:","text":"<p>Download OHLCV futures data from Binance</p> <pre><code>from tradingtoolbox.exchanges import binanceklines, timeframes\n\nklines = binanceklines()\nohlcv = klines.get_futures_klines(\n    timeframes.tf_1hour, asset=\"btcusdt\", ago=\"1 day ago utc\"\n)\n</code></pre> <p>Connect to a ClickHouse database, and write the OHLCV data to it</p> <pre><code>from tradingtoolbox.clickhouse import ClickhouseSync\n\nclient = ClickhouseSync.create(\n    host=\"localhost\",\n    port=8123,\n    user=\"default\",\n    password=\"\",\n    database=\"default\",\n)\n\n# Or you can create it without passing anything, and it will use the above defaults\nasync_client = ClickhouseSync.create()\n\nclient.insert_df(ohlcv, \"OHLCV\")\n</code></pre> <p>Upgraded Log that uses rich and writes to a file in a format friendly for loki. (Will be released in the future)</p> <pre><code>from tradingtoolbox.utils import print\n\nprint(ohlv)\n\n&gt;&gt;&gt; [09/29/24 01:52:04]              open     high      low    close    volume    asset timeframe\n                Date\n                2024-09-27 19:00:00  65844.0  65953.9  65600.0  65612.8  5857.933  BTCUSDT        1h\n                2024-09-27 20:00:00  65612.9  65884.3  65587.2  65770.1  3534.253  BTCUSDT        1h\n                2024-09-27 21:00:00  65770.0  65854.8  65724.4  65785.1  2041.993  BTCUSDT        1h\n                2024-09-27 22:00:00  65785.1  65950.0  65732.8  65839.0  3656.832  BTCUSDT        1h\n                2024-09-27 23:00:00  65839.1  65885.2  65653.5  65749.6  3746.322  BTCUSDT        1h\n                2024-09-28 00:00:00  65749.5  65880.0  65692.3  65876.3  2840.027  BTCUSDT        1h\n                2024-09-28 01:00:00  65876.4  65980.0  65764.2  65959.2  2401.330  BTCUSDT        1h\n                2024-09-28 02:00:00  65959.2  66161.7  65868.3  66131.3  5686.056  BTCUSDT        1h\n                2024-09-28 03:00:00  66131.3  66237.0  65955.5  66041.0  4308.866  BTCUSDT        1h\n                2024-09-28 04:00:00  66041.0  66060.1  65924.8  65982.0  2575.826  BTCUSDT        1h\n                2024-09-28 05:00:00  65982.1  65997.5  65866.8  65922.2  2962.115  BTCUSDT        1h\n                2024-09-28 06:00:00  65922.1  65930.1  65706.1  65778.7  4484.971  BTCUSDT        1h\n                2024-09-28 07:00:00  65778.7  65870.0  65721.4  65790.0  2598.911  BTCUSDT        1h\n                2024-09-28 08:00:00  65790.0  65790.1  65522.0  65606.9  6669.400  BTCUSDT        1h\n                2024-09-28 09:00:00  65606.9  65617.2  65392.7  65602.3  7307.201  BTCUSDT        1h\n                2024-09-28 10:00:00  65602.3  65745.0  65545.0  65730.6  3458.654  BTCUSDT        1h\n                2024-09-28 11:00:00  65730.7  65775.8  65664.9  65761.5  2453.674  BTCUSDT        1h\n                2024-09-28 12:00:00  65761.5  65765.3  65389.9  65508.4  7659.598  BTCUSDT        1h\n                2024-09-28 13:00:00  65508.3  65574.3  65368.1  65498.2  4304.011  BTCUSDT        1h\n                2024-09-28 14:00:00  65498.1  65796.8  65498.1  65689.9  5885.235  BTCUSDT        1h\n                2024-09-28 15:00:00  65689.9  65689.9  65586.0  65593.7  2623.209  BTCUSDT        1h\n                2024-09-28 16:00:00  65593.6  65640.7  65460.0  65485.9  3219.377  BTCUSDT        1h\n                2024-09-28 17:00:00  65485.8  65696.0  65477.4  65603.0  2010.361  BTCUSDT        1h\n                2024-09-28 18:00:00  65603.0  65798.7  65602.9  65736.0  1426.067  BTCUSDT        1h\n</code></pre>"},{"location":"reference/tradingtoolbox/__init__/","title":"Tradingtoolbox","text":"<p>Trading Toolbox</p> <p>A Python library providing essential tools for traders to manage and interact with financial market data. This library consists of three main modules: exchange kline download, database management, and general utilities.</p> <p>Attributes:</p> Name Type Description <code>clickhouse</code> <code>module</code> <p>Functions for database-related operations.</p> <code>exchanges</code> <code>module</code> <p>Functions to download and manage OHLCV data.</p> <code>utils</code> <code>module</code> <p>Utility functions for time manipulation, logging, and other tasks.</p> <code>cache</code> <code>module</code> <p>Utility that automatically takes care of caching data to local disk</p> Example <p>Download OHLCV futures data from Binance</p> <pre><code>from tradingtoolbox.exchanges import binanceklines, timeframes\n\nklines = binanceklines()\nohlcv = klines.get_futures_klines(\n    timeframes.tf_1hour, asset=\"btcusdt\", ago=\"1 day ago utc\"\n)\n</code></pre> <p>Connect to a ClickHouse database, and write the OHLCV data to it</p> <pre><code>from tradingtoolbox.clickhouse import ClickhouseSync\n\nclient = ClickhouseSync.create(\n    host=\"localhost\",\n    port=8123,\n    user=\"default\",\n    password=\"\",\n    database=\"default\",\n)\n\n# Or you can create it without passing anything, and it will use the above defaults\nasync_client = ClickhouseSync.create()\n\nclient.insert_df(ohlcv, \"OHLCV\")\n</code></pre> <p>Upgraded Log that uses rich and writes to a file in a format friendly for loki. (Will be released in the future)</p> <pre><code>from tradingtoolbox.utils import print\n\nprint(ohlv)\n\n&gt;&gt;&gt; [09/29/24 01:52:04]              open     high      low    close    volume    asset timeframe\n                Date\n                2024-09-27 19:00:00  65844.0  65953.9  65600.0  65612.8  5857.933  BTCUSDT        1h\n                2024-09-27 20:00:00  65612.9  65884.3  65587.2  65770.1  3534.253  BTCUSDT        1h\n                2024-09-27 21:00:00  65770.0  65854.8  65724.4  65785.1  2041.993  BTCUSDT        1h\n                2024-09-27 22:00:00  65785.1  65950.0  65732.8  65839.0  3656.832  BTCUSDT        1h\n                2024-09-27 23:00:00  65839.1  65885.2  65653.5  65749.6  3746.322  BTCUSDT        1h\n                2024-09-28 00:00:00  65749.5  65880.0  65692.3  65876.3  2840.027  BTCUSDT        1h\n                2024-09-28 01:00:00  65876.4  65980.0  65764.2  65959.2  2401.330  BTCUSDT        1h\n                2024-09-28 02:00:00  65959.2  66161.7  65868.3  66131.3  5686.056  BTCUSDT        1h\n                2024-09-28 03:00:00  66131.3  66237.0  65955.5  66041.0  4308.866  BTCUSDT        1h\n                2024-09-28 04:00:00  66041.0  66060.1  65924.8  65982.0  2575.826  BTCUSDT        1h\n                2024-09-28 05:00:00  65982.1  65997.5  65866.8  65922.2  2962.115  BTCUSDT        1h\n                2024-09-28 06:00:00  65922.1  65930.1  65706.1  65778.7  4484.971  BTCUSDT        1h\n                2024-09-28 07:00:00  65778.7  65870.0  65721.4  65790.0  2598.911  BTCUSDT        1h\n                2024-09-28 08:00:00  65790.0  65790.1  65522.0  65606.9  6669.400  BTCUSDT        1h\n                2024-09-28 09:00:00  65606.9  65617.2  65392.7  65602.3  7307.201  BTCUSDT        1h\n                2024-09-28 10:00:00  65602.3  65745.0  65545.0  65730.6  3458.654  BTCUSDT        1h\n                2024-09-28 11:00:00  65730.7  65775.8  65664.9  65761.5  2453.674  BTCUSDT        1h\n                2024-09-28 12:00:00  65761.5  65765.3  65389.9  65508.4  7659.598  BTCUSDT        1h\n                2024-09-28 13:00:00  65508.3  65574.3  65368.1  65498.2  4304.011  BTCUSDT        1h\n                2024-09-28 14:00:00  65498.1  65796.8  65498.1  65689.9  5885.235  BTCUSDT        1h\n                2024-09-28 15:00:00  65689.9  65689.9  65586.0  65593.7  2623.209  BTCUSDT        1h\n                2024-09-28 16:00:00  65593.6  65640.7  65460.0  65485.9  3219.377  BTCUSDT        1h\n                2024-09-28 17:00:00  65485.8  65696.0  65477.4  65603.0  2010.361  BTCUSDT        1h\n                2024-09-28 18:00:00  65603.0  65798.7  65602.9  65736.0  1426.067  BTCUSDT        1h\n</code></pre>"},{"location":"reference/tradingtoolbox/dev_testing/","title":"Dev testing","text":""},{"location":"reference/tradingtoolbox/clickhouse/__init__/","title":"Clickhouse","text":""},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseAsync","title":"<code>ClickhouseAsync</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An async clickhouse client.</p> Usage <pre><code>from tradingtoolbox.clickhouse import ClickhouseAsync\n\nasync_client = await ClickhouseAsync.create(\n    host=\"localhost\",\n    port=8123,\n    user=\"default\",\n    password=\"\",\n    database=\"default\",\n)\n\n# Or you can create it without passing anything, and it will use the above defaults\nasync_client = await ClickhouseAsync.create()\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseAsync.create_table","title":"<code>create_table(table_name, schema, partition_key='', order_by='', primary_key='', drop=False)</code>","text":"<p>Create a table</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table</p> required <code>schema</code> <code>str</code> <p>The schema of the table</p> required <code>partition_key</code> <code>str</code> <p>The partition key</p> <code>''</code> <code>order_by</code> <code>str</code> <p>The order by</p> <code>''</code> <code>primary_key</code> <code>str</code> <p>The primary key</p> <code>''</code> <code>drop</code> <code>bool</code> <p>Whether to drop the table if it already exists</p> <code>False</code> Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>    async def create_table(\n        self,\n        table_name: str,\n        schema: str,\n        partition_key: str = \"\",\n        order_by: str = \"\",\n        primary_key: str = \"\",\n        drop: bool = False,\n    ):\n        \"\"\"\n        Create a table\n\n        Parameters:\n            table_name: The name of the table\n            schema: The schema of the table\n            partition_key: The partition key\n            order_by: The order by\n            primary_key: The primary key\n            drop: Whether to drop the table if it already exists\n        \"\"\"\n        if drop:\n            await self.drop_table(table_name)\n\n        query_string = f\"\"\"\nCREATE TABLE IF NOT EXISTS {table_name} (\n    {schema}\n)\nENGINE = ReplacingMergeTree()\n{partition_key}\n{order_by}\n{primary_key}\n\"\"\"\n        # print(query_string)\n        return await self.execute_command(query_string)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseAsync.drop_table","title":"<code>drop_table(table_name)</code>","text":"<p>Drops a table from the database</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The table's name</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def drop_table(self, table_name: str):\n    \"\"\"\n    Drops a table from the database\n\n    Parameters:\n        table_name: The table's name\n    \"\"\"\n    return await self.execute_command(f\"DROP TABLE IF EXISTS {table_name}\")\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseAsync.execute_command","title":"<code>execute_command(query)</code>","text":"<p>Allows you to run any command you want</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to execute</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def execute_command(self, query: str):\n    \"\"\"\n    Allows you to run any command you want\n\n    Parameters:\n        query: The query to execute\n    \"\"\"\n    await self.async_client.command(query)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseAsync.insert_df","title":"<code>insert_df(df, table_name, drop=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to insert</p> required <code>table_name</code> <code>str</code> <p>The name of the table to insert into</p> required <code>drop</code> <code>bool</code> <p>Whether to drop the table if it already exists</p> <code>False</code> Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def insert_df(self, df: pd.DataFrame, table_name: str, drop: bool = False):\n    \"\"\"\n    Parameters:\n        df: The dataframe to insert\n        table_name: The name of the table to insert into\n        drop: Whether to drop the table if it already exists\n    \"\"\"\n    if drop:\n        await self.drop_table(table_name)\n    schema = generate_table_schema(df, table_name)\n\n    await self.async_client.insert_df(table_name, df)\n    await self.async_client.command(schema)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseAsync.optimize_table","title":"<code>optimize_table(table_name)</code>","text":"<p>Optimizes a table</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def optimize_table(self, table_name: str):\n    \"\"\"\n    Optimizes a table\n\n    Parameters:\n        table_name: The name of the table\n    \"\"\"\n    command = f\"OPTIMIZE TABLE {table_name} FINAL\"\n    return await self.execute_command(command)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseAsync.query","title":"<code>query(query)</code>","text":"<p>Runs a query</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to run</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def query(self, query: str):\n    \"\"\"\n    Runs a query\n\n    Parameters:\n        query: The query to run\n    \"\"\"\n    return await self.async_client.query(query)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseAsync.query_df","title":"<code>query_df(query)</code>","text":"<p>Runs a query and returns the results as a dataframe</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to run</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def query_df(self, query: str):\n    \"\"\"\n    Runs a query and returns the results as a dataframe\n\n    Parameters:\n        query: The query to run\n    \"\"\"\n    return await self.async_client.query_df(query)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseSync","title":"<code>ClickhouseSync</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An sync clickhouse client.</p> Usage <pre><code>from tradingtoolbox.clickhouse import ClickhouseSync\n\nclient = ClickhouseSync.create(\n    host=\"localhost\",\n    port=8123,\n    user=\"default\",\n    password=\"\",\n    database=\"default\",\n)\n\n# Or you can create it without passing anything, and it will use the above defaults\nasync_client = ClickhouseSync.create()\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseSync.create_table","title":"<code>create_table(table_name, schema, partition_key='', order_by='', primary_key='', drop=False)</code>","text":"<p>Create a table</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table</p> required <code>schema</code> <code>str</code> <p>The schema of the table</p> required <code>partition_key</code> <code>str</code> <p>The partition key</p> <code>''</code> <code>order_by</code> <code>str</code> <p>The order by</p> <code>''</code> <code>primary_key</code> <code>str</code> <p>The primary key</p> <code>''</code> <code>drop</code> <code>bool</code> <p>Whether to drop the table if it already exists</p> <code>False</code> Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>    def create_table(\n        self,\n        table_name: str,\n        schema: str,\n        partition_key: str = \"\",\n        order_by: str = \"\",\n        primary_key: str = \"\",\n        drop: bool = False,\n    ):\n        \"\"\"\n        Create a table\n\n        Parameters:\n            table_name: The name of the table\n            schema: The schema of the table\n            partition_key: The partition key\n            order_by: The order by\n            primary_key: The primary key\n            drop: Whether to drop the table if it already exists\n        \"\"\"\n        if drop:\n            self.drop_table(table_name)\n\n        query_string = f\"\"\"\nCREATE TABLE IF NOT EXISTS {table_name} (\n    {schema}\n)\nENGINE = ReplacingMergeTree()\n{partition_key}\n{order_by}\n{primary_key}\n\"\"\"\n        # print(query_string)\n        return self.execute_command(query_string)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseSync.drop_table","title":"<code>drop_table(table_name)</code>","text":"<p>Drops a table from the database</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The table's name</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def drop_table(self, table_name: str):\n    \"\"\"\n    Drops a table from the database\n\n    Parameters:\n        table_name: The table's name\n    \"\"\"\n    return self.execute_command(f\"DROP TABLE IF EXISTS {table_name}\")\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseSync.execute_command","title":"<code>execute_command(msg)</code>","text":"<p>Allows you to run any command you want</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <p>The query to execute</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def execute_command(self, msg: str):\n    \"\"\"\n    Allows you to run any command you want\n\n    Parameters:\n        query: The query to execute\n    \"\"\"\n    self.client.command(msg)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseSync.insert_df","title":"<code>insert_df(df, table_name, drop=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to insert</p> required <code>table_name</code> <code>str</code> <p>The name of the table to insert into</p> required <code>drop</code> <p>Whether to drop the table if it already exists</p> <code>False</code> Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def insert_df(self, df: pd.DataFrame, table_name: str, drop=False):\n    \"\"\"\n    Parameters:\n        df: The dataframe to insert\n        table_name: The name of the table to insert into\n        drop: Whether to drop the table if it already exists\n    \"\"\"\n    if drop:\n        self.drop_table(table_name)\n    schema = generate_table_schema(df, table_name)\n\n    self.client.command(schema)\n    self.client.insert_df(table_name, df)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseSync.optimize_table","title":"<code>optimize_table(table_name)</code>","text":"<p>Optimizes a table</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def optimize_table(self, table_name: str):\n    \"\"\"\n    Optimizes a table\n\n    Parameters:\n        table_name: The name of the table\n    \"\"\"\n    command = f\"OPTIMIZE TABLE {table_name} FINAL\"\n    return self.execute_command(command)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseSync.query","title":"<code>query(query)</code>","text":"<p>Runs a query</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to run</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def query(self, query: str):\n    \"\"\"\n    Runs a query\n\n    Parameters:\n        query: The query to run\n    \"\"\"\n    return self.client.query(query)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/__init__/#tradingtoolbox.clickhouse.ClickhouseSync.query_df","title":"<code>query_df(query)</code>","text":"<p>Runs a query and returns the results as a dataframe</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to run</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def query_df(self, query: str):\n    \"\"\"\n    Runs a query and returns the results as a dataframe\n\n    Parameters:\n        query: The query to run\n    \"\"\"\n    return self.client.query_df(query)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_async/","title":"Clickhouse async","text":""},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_async/#tradingtoolbox.clickhouse.clickhouse_async.ClickhouseAsync","title":"<code>ClickhouseAsync</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An async clickhouse client.</p> Usage <pre><code>from tradingtoolbox.clickhouse import ClickhouseAsync\n\nasync_client = await ClickhouseAsync.create(\n    host=\"localhost\",\n    port=8123,\n    user=\"default\",\n    password=\"\",\n    database=\"default\",\n)\n\n# Or you can create it without passing anything, and it will use the above defaults\nasync_client = await ClickhouseAsync.create()\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_async/#tradingtoolbox.clickhouse.clickhouse_async.ClickhouseAsync.create_table","title":"<code>create_table(table_name, schema, partition_key='', order_by='', primary_key='', drop=False)</code>","text":"<p>Create a table</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table</p> required <code>schema</code> <code>str</code> <p>The schema of the table</p> required <code>partition_key</code> <code>str</code> <p>The partition key</p> <code>''</code> <code>order_by</code> <code>str</code> <p>The order by</p> <code>''</code> <code>primary_key</code> <code>str</code> <p>The primary key</p> <code>''</code> <code>drop</code> <code>bool</code> <p>Whether to drop the table if it already exists</p> <code>False</code> Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>    async def create_table(\n        self,\n        table_name: str,\n        schema: str,\n        partition_key: str = \"\",\n        order_by: str = \"\",\n        primary_key: str = \"\",\n        drop: bool = False,\n    ):\n        \"\"\"\n        Create a table\n\n        Parameters:\n            table_name: The name of the table\n            schema: The schema of the table\n            partition_key: The partition key\n            order_by: The order by\n            primary_key: The primary key\n            drop: Whether to drop the table if it already exists\n        \"\"\"\n        if drop:\n            await self.drop_table(table_name)\n\n        query_string = f\"\"\"\nCREATE TABLE IF NOT EXISTS {table_name} (\n    {schema}\n)\nENGINE = ReplacingMergeTree()\n{partition_key}\n{order_by}\n{primary_key}\n\"\"\"\n        # print(query_string)\n        return await self.execute_command(query_string)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_async/#tradingtoolbox.clickhouse.clickhouse_async.ClickhouseAsync.drop_table","title":"<code>drop_table(table_name)</code>","text":"<p>Drops a table from the database</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The table's name</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def drop_table(self, table_name: str):\n    \"\"\"\n    Drops a table from the database\n\n    Parameters:\n        table_name: The table's name\n    \"\"\"\n    return await self.execute_command(f\"DROP TABLE IF EXISTS {table_name}\")\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_async/#tradingtoolbox.clickhouse.clickhouse_async.ClickhouseAsync.execute_command","title":"<code>execute_command(query)</code>","text":"<p>Allows you to run any command you want</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to execute</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def execute_command(self, query: str):\n    \"\"\"\n    Allows you to run any command you want\n\n    Parameters:\n        query: The query to execute\n    \"\"\"\n    await self.async_client.command(query)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_async/#tradingtoolbox.clickhouse.clickhouse_async.ClickhouseAsync.insert_df","title":"<code>insert_df(df, table_name, drop=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to insert</p> required <code>table_name</code> <code>str</code> <p>The name of the table to insert into</p> required <code>drop</code> <code>bool</code> <p>Whether to drop the table if it already exists</p> <code>False</code> Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def insert_df(self, df: pd.DataFrame, table_name: str, drop: bool = False):\n    \"\"\"\n    Parameters:\n        df: The dataframe to insert\n        table_name: The name of the table to insert into\n        drop: Whether to drop the table if it already exists\n    \"\"\"\n    if drop:\n        await self.drop_table(table_name)\n    schema = generate_table_schema(df, table_name)\n\n    await self.async_client.insert_df(table_name, df)\n    await self.async_client.command(schema)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_async/#tradingtoolbox.clickhouse.clickhouse_async.ClickhouseAsync.optimize_table","title":"<code>optimize_table(table_name)</code>","text":"<p>Optimizes a table</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def optimize_table(self, table_name: str):\n    \"\"\"\n    Optimizes a table\n\n    Parameters:\n        table_name: The name of the table\n    \"\"\"\n    command = f\"OPTIMIZE TABLE {table_name} FINAL\"\n    return await self.execute_command(command)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_async/#tradingtoolbox.clickhouse.clickhouse_async.ClickhouseAsync.query","title":"<code>query(query)</code>","text":"<p>Runs a query</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to run</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def query(self, query: str):\n    \"\"\"\n    Runs a query\n\n    Parameters:\n        query: The query to run\n    \"\"\"\n    return await self.async_client.query(query)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_async/#tradingtoolbox.clickhouse.clickhouse_async.ClickhouseAsync.query_df","title":"<code>query_df(query)</code>","text":"<p>Runs a query and returns the results as a dataframe</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to run</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_async.py</code> <pre><code>async def query_df(self, query: str):\n    \"\"\"\n    Runs a query and returns the results as a dataframe\n\n    Parameters:\n        query: The query to run\n    \"\"\"\n    return await self.async_client.query_df(query)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_sync/","title":"Clickhouse sync","text":""},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_sync/#tradingtoolbox.clickhouse.clickhouse_sync.ClickhouseSync","title":"<code>ClickhouseSync</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>An sync clickhouse client.</p> Usage <pre><code>from tradingtoolbox.clickhouse import ClickhouseSync\n\nclient = ClickhouseSync.create(\n    host=\"localhost\",\n    port=8123,\n    user=\"default\",\n    password=\"\",\n    database=\"default\",\n)\n\n# Or you can create it without passing anything, and it will use the above defaults\nasync_client = ClickhouseSync.create()\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_sync/#tradingtoolbox.clickhouse.clickhouse_sync.ClickhouseSync.create_table","title":"<code>create_table(table_name, schema, partition_key='', order_by='', primary_key='', drop=False)</code>","text":"<p>Create a table</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table</p> required <code>schema</code> <code>str</code> <p>The schema of the table</p> required <code>partition_key</code> <code>str</code> <p>The partition key</p> <code>''</code> <code>order_by</code> <code>str</code> <p>The order by</p> <code>''</code> <code>primary_key</code> <code>str</code> <p>The primary key</p> <code>''</code> <code>drop</code> <code>bool</code> <p>Whether to drop the table if it already exists</p> <code>False</code> Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>    def create_table(\n        self,\n        table_name: str,\n        schema: str,\n        partition_key: str = \"\",\n        order_by: str = \"\",\n        primary_key: str = \"\",\n        drop: bool = False,\n    ):\n        \"\"\"\n        Create a table\n\n        Parameters:\n            table_name: The name of the table\n            schema: The schema of the table\n            partition_key: The partition key\n            order_by: The order by\n            primary_key: The primary key\n            drop: Whether to drop the table if it already exists\n        \"\"\"\n        if drop:\n            self.drop_table(table_name)\n\n        query_string = f\"\"\"\nCREATE TABLE IF NOT EXISTS {table_name} (\n    {schema}\n)\nENGINE = ReplacingMergeTree()\n{partition_key}\n{order_by}\n{primary_key}\n\"\"\"\n        # print(query_string)\n        return self.execute_command(query_string)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_sync/#tradingtoolbox.clickhouse.clickhouse_sync.ClickhouseSync.drop_table","title":"<code>drop_table(table_name)</code>","text":"<p>Drops a table from the database</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The table's name</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def drop_table(self, table_name: str):\n    \"\"\"\n    Drops a table from the database\n\n    Parameters:\n        table_name: The table's name\n    \"\"\"\n    return self.execute_command(f\"DROP TABLE IF EXISTS {table_name}\")\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_sync/#tradingtoolbox.clickhouse.clickhouse_sync.ClickhouseSync.execute_command","title":"<code>execute_command(msg)</code>","text":"<p>Allows you to run any command you want</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <p>The query to execute</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def execute_command(self, msg: str):\n    \"\"\"\n    Allows you to run any command you want\n\n    Parameters:\n        query: The query to execute\n    \"\"\"\n    self.client.command(msg)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_sync/#tradingtoolbox.clickhouse.clickhouse_sync.ClickhouseSync.insert_df","title":"<code>insert_df(df, table_name, drop=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to insert</p> required <code>table_name</code> <code>str</code> <p>The name of the table to insert into</p> required <code>drop</code> <p>Whether to drop the table if it already exists</p> <code>False</code> Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def insert_df(self, df: pd.DataFrame, table_name: str, drop=False):\n    \"\"\"\n    Parameters:\n        df: The dataframe to insert\n        table_name: The name of the table to insert into\n        drop: Whether to drop the table if it already exists\n    \"\"\"\n    if drop:\n        self.drop_table(table_name)\n    schema = generate_table_schema(df, table_name)\n\n    self.client.command(schema)\n    self.client.insert_df(table_name, df)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_sync/#tradingtoolbox.clickhouse.clickhouse_sync.ClickhouseSync.optimize_table","title":"<code>optimize_table(table_name)</code>","text":"<p>Optimizes a table</p> <p>Parameters:</p> Name Type Description Default <code>table_name</code> <code>str</code> <p>The name of the table</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def optimize_table(self, table_name: str):\n    \"\"\"\n    Optimizes a table\n\n    Parameters:\n        table_name: The name of the table\n    \"\"\"\n    command = f\"OPTIMIZE TABLE {table_name} FINAL\"\n    return self.execute_command(command)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_sync/#tradingtoolbox.clickhouse.clickhouse_sync.ClickhouseSync.query","title":"<code>query(query)</code>","text":"<p>Runs a query</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to run</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def query(self, query: str):\n    \"\"\"\n    Runs a query\n\n    Parameters:\n        query: The query to run\n    \"\"\"\n    return self.client.query(query)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/clickhouse_sync/#tradingtoolbox.clickhouse.clickhouse_sync.ClickhouseSync.query_df","title":"<code>query_df(query)</code>","text":"<p>Runs a query and returns the results as a dataframe</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>The query to run</p> required Source code in <code>src/tradingtoolbox/clickhouse/clickhouse_sync.py</code> <pre><code>def query_df(self, query: str):\n    \"\"\"\n    Runs a query and returns the results as a dataframe\n\n    Parameters:\n        query: The query to run\n    \"\"\"\n    return self.client.query_df(query)\n</code></pre>"},{"location":"reference/tradingtoolbox/clickhouse/generate_table_schema/","title":"Generate table schema","text":""},{"location":"reference/tradingtoolbox/clickhouse/generate_table_schema/#tradingtoolbox.clickhouse.generate_table_schema.generate_table_schema","title":"<code>generate_table_schema(df, table_name)</code>","text":"<p>Generates the schema for a table from a pandas dataframe</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to generate the schema from</p> required <code>table_name</code> <code>str</code> <p>The name of the table to insert the df into</p> required Source code in <code>src/tradingtoolbox/clickhouse/generate_table_schema.py</code> <pre><code>def generate_table_schema(df: pd.DataFrame, table_name: str):\n    \"\"\"\n    Generates the schema for a table from a pandas dataframe\n\n    Parameters:\n        df: The dataframe to generate the schema from\n        table_name: The name of the table to insert the df into\n    \"\"\"\n    schema = f\"CREATE TABLE IF NOT EXISTS {table_name} (\"\n    for column in df.columns:\n        dtype = df[column].dtype\n        if dtype == \"int64\":\n            clickhouse_type = \"Int32\"\n        elif dtype == \"float64\":\n            clickhouse_type = \"Float64\"\n        elif dtype == \"bool\":\n            clickhouse_type = \"UInt8\"\n        elif dtype == \"datetime64[ns]\" or dtype == \"datetime64[ns, UTC]\":\n            clickhouse_type = \"DateTime\"\n        else:\n            clickhouse_type = \"String\"\n        schema += f\"{column} {clickhouse_type}, \"\n    schema = schema.rstrip(\", \") + \") ENGINE = MergeTree ORDER BY tuple()\"\n    return schema\n</code></pre>"},{"location":"reference/tradingtoolbox/exchanges/__init__/","title":"Exchanges","text":""},{"location":"reference/tradingtoolbox/exchanges/__init__/#tradingtoolbox.exchanges.BinanceKlines","title":"<code>BinanceKlines</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A class that allows downloading klines from Binance.</p> Usage <pre><code>from tradingtoolbox.exchanges import BinanceKlines, Timeframes\n\nklines = BinanceKlines()\ndf = klines.get_futures_klines(\n    Timeframes.TF_1HOUR, asset=\"BTCUSDT\", ago=\"1 day ago UTC\"\n)\n</code></pre>"},{"location":"reference/tradingtoolbox/exchanges/__init__/#tradingtoolbox.exchanges.BinanceKlines.get_futures_klines","title":"<code>get_futures_klines(tf, asset='BTCUSDT', ago='1 day ago UTC', cache=True, data_directory='./data', set_index=True)</code>","text":"<p>Fetches the Futures (Perp Swaps) klines</p> <p>Parameters:</p> Name Type Description Default <code>tf</code> <code>Timeframes</code> <p>The timeframe to fetch.</p> required <code>asset</code> <code>str</code> <p>The asset name.</p> <code>'BTCUSDT'</code> <code>ago</code> <code>str</code> <p>The time ago you want to fetch it. Ex: '30 day ago UTC', or '3 months ago UTC'</p> <code>'1 day ago UTC'</code> <code>cache</code> <code>bool</code> <p>Whether to cache the data. Subsequent calls will not call the API.</p> <code>True</code> <code>data_directory</code> <code>str</code> <p>The directory where the klines fill be stored as parquet files</p> <code>'./data'</code> <code>set_index</code> <code>bool</code> <p>Whether to set the index of the returned DataFrame. If True, the 'Date' column will be set as index</p> <code>True</code> Source code in <code>src/tradingtoolbox/exchanges/binance.py</code> <pre><code>def get_futures_klines(\n    self,\n    tf: Timeframes,\n    asset: str = \"BTCUSDT\",\n    ago: str = \"1 day ago UTC\",\n    cache: bool = True,\n    data_directory: str = \"./data\",\n    set_index: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches the Futures (Perp Swaps) klines\n\n    Parameters:\n        tf: The timeframe to fetch.\n        asset: The asset name.\n        ago: The time ago you want to fetch it. Ex: '30 day ago UTC', or '3 months ago UTC'\n        cache: Whether to cache the data. Subsequent calls will **not** call the API.\n        data_directory: The directory where the klines fill be stored as parquet files\n        set_index: Whether to set the index of the returned DataFrame. If True, the 'Date' column will be set as index\n    \"\"\"\n    return self._get_klines(\n        asset_type=\"futures\",\n        tf=tf,\n        asset=asset,\n        ago=ago,\n        cache=cache,\n        data_directory=data_directory,\n        set_index=set_index,\n    )\n</code></pre>"},{"location":"reference/tradingtoolbox/exchanges/__init__/#tradingtoolbox.exchanges.OKXKlines","title":"<code>OKXKlines</code>","text":"<p>A class that helps downloading klines from OKX.</p> Usage <pre><code>from tradingtoolbox.exchanges import OKXKlines\n\n\nklines = OKXKlines()\ndf = klines.load_klines(\n    \"PEPE-USDT-SWAP\", \"1m\", days_ago=30\n)\n</code></pre>"},{"location":"reference/tradingtoolbox/exchanges/__init__/#tradingtoolbox.exchanges.OKXKlines.load_klines","title":"<code>load_klines(instrument, tf, days_ago=1, end=datetime.now())</code>","text":"<p>Load klines from the past X days. OKX's api is limited in to a max of 100 items. This method, will loop until it finds the amount needed</p> <p>Parameters:</p> Name Type Description Default <code>instrument</code> <code>str</code> <p>The instrument to fetch</p> required <code>tf</code> <code>str</code> <p>The timeframe to fetch</p> required <code>days_ago</code> <code>int</code> <p>The number of days ago to look at</p> <code>1</code> <code>end</code> <p>The end date</p> <code>now()</code> Source code in <code>src/tradingtoolbox/exchanges/okx.py</code> <pre><code>def load_klines(\n    self, instrument: str, tf: str, days_ago: int = 1, end=datetime.now()\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load klines from the past X days.\n    OKX's api is limited in to a max of 100 items. This method, will loop until it finds the amount needed\n\n    Parameters:\n        instrument: The instrument to fetch\n        tf: The timeframe to fetch\n        days_ago: The number of days ago to look at\n        end: The end date\n    \"\"\"\n    df = self._find_kline_file(instrument, tf)\n\n    if df is None:\n        df = self._fetch_lines(instrument, tf, None)\n\n    start_date = end - pd.Timedelta(days=days_ago)\n    while start_date.timestamp() &lt; df[\"date\"].min():  # type: ignore\n        new_df = self._fetch_lines(instrument, tf, df[\"date\"].min())\n        df = pd.concat([df, new_df])\n        df[\"d\"] = pd.to_datetime(df[\"date\"], unit=\"ms\")\n        name = self._get_kline_file_name(instrument, tf)\n        print(name)\n        df.to_parquet(self._get_kline_file_name(instrument, tf))\n        time.sleep(0.1)\n        print(df)\n\n    df = df.sort_values(by=[\"date\"], ascending=True)\n    df[\"date\"] = pd.to_datetime(df[\"date\"], unit=\"ms\")\n    return df\n</code></pre>"},{"location":"reference/tradingtoolbox/exchanges/__init__/#tradingtoolbox.exchanges.Timeframes","title":"<code>Timeframes</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Timeframes for Binance</p> <p>Usage:</p> <p>Attributes:</p> Name Type Description <code>TF_1MINUTE</code> <code>Literal</code> <p>Binance 1 minute interval.</p> <code>TF_3MINUTE</code> <code>Literal</code> <p>Binance 3 minute interval.</p> <code>TF_5MINUTE</code> <code>Literal</code> <p>Binance 5 minute interval.</p> <code>TF_15MINUTE</code> <code>Literal</code> <p>Binance 15 minute interval.</p> <code>TF_30MINUTE</code> <code>Literal</code> <p>Binance 30 minute interval.</p> <code>TF_1HOUR</code> <code>Literal</code> <p>Binance 1 hour interval.</p> <code>TF_2HOUR</code> <code>Literal</code> <p>Binance 2 hour interval.</p> <code>TF_4HOUR</code> <code>Literal</code> <p>Binance 4 hour interval.</p> <code>TF_6HOUR</code> <code>Literal</code> <p>Binance 6 hour interval.</p> <code>TF_8HOUR</code> <code>Literal</code> <p>Binance 8 hour interval.</p> <code>TF_12HOUR</code> <code>Literal</code> <p>Binance 12 hour interval.</p> <code>TF_1DAY</code> <code>Literal</code> <p>Binance 1 day interval.</p> <code>TF_3DAY</code> <code>Literal</code> <p>Binance 3 day interval.</p> <code>TF_1WEEK</code> <code>Literal</code> <p>Binance 1 week interval.</p> <code>TF_1MONTH</code> <code>Literal</code> <p>Binance 1 month interval.</p>"},{"location":"reference/tradingtoolbox/exchanges/binance/","title":"Binance","text":""},{"location":"reference/tradingtoolbox/exchanges/binance/#tradingtoolbox.exchanges.binance.BinanceKlines","title":"<code>BinanceKlines</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>A class that allows downloading klines from Binance.</p> Usage <pre><code>from tradingtoolbox.exchanges import BinanceKlines, Timeframes\n\nklines = BinanceKlines()\ndf = klines.get_futures_klines(\n    Timeframes.TF_1HOUR, asset=\"BTCUSDT\", ago=\"1 day ago UTC\"\n)\n</code></pre>"},{"location":"reference/tradingtoolbox/exchanges/binance/#tradingtoolbox.exchanges.binance.BinanceKlines.get_futures_klines","title":"<code>get_futures_klines(tf, asset='BTCUSDT', ago='1 day ago UTC', cache=True, data_directory='./data', set_index=True)</code>","text":"<p>Fetches the Futures (Perp Swaps) klines</p> <p>Parameters:</p> Name Type Description Default <code>tf</code> <code>Timeframes</code> <p>The timeframe to fetch.</p> required <code>asset</code> <code>str</code> <p>The asset name.</p> <code>'BTCUSDT'</code> <code>ago</code> <code>str</code> <p>The time ago you want to fetch it. Ex: '30 day ago UTC', or '3 months ago UTC'</p> <code>'1 day ago UTC'</code> <code>cache</code> <code>bool</code> <p>Whether to cache the data. Subsequent calls will not call the API.</p> <code>True</code> <code>data_directory</code> <code>str</code> <p>The directory where the klines fill be stored as parquet files</p> <code>'./data'</code> <code>set_index</code> <code>bool</code> <p>Whether to set the index of the returned DataFrame. If True, the 'Date' column will be set as index</p> <code>True</code> Source code in <code>src/tradingtoolbox/exchanges/binance.py</code> <pre><code>def get_futures_klines(\n    self,\n    tf: Timeframes,\n    asset: str = \"BTCUSDT\",\n    ago: str = \"1 day ago UTC\",\n    cache: bool = True,\n    data_directory: str = \"./data\",\n    set_index: bool = True,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Fetches the Futures (Perp Swaps) klines\n\n    Parameters:\n        tf: The timeframe to fetch.\n        asset: The asset name.\n        ago: The time ago you want to fetch it. Ex: '30 day ago UTC', or '3 months ago UTC'\n        cache: Whether to cache the data. Subsequent calls will **not** call the API.\n        data_directory: The directory where the klines fill be stored as parquet files\n        set_index: Whether to set the index of the returned DataFrame. If True, the 'Date' column will be set as index\n    \"\"\"\n    return self._get_klines(\n        asset_type=\"futures\",\n        tf=tf,\n        asset=asset,\n        ago=ago,\n        cache=cache,\n        data_directory=data_directory,\n        set_index=set_index,\n    )\n</code></pre>"},{"location":"reference/tradingtoolbox/exchanges/binance/#tradingtoolbox.exchanges.binance.Timeframes","title":"<code>Timeframes</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Timeframes for Binance</p> <p>Usage:</p> <p>Attributes:</p> Name Type Description <code>TF_1MINUTE</code> <code>Literal</code> <p>Binance 1 minute interval.</p> <code>TF_3MINUTE</code> <code>Literal</code> <p>Binance 3 minute interval.</p> <code>TF_5MINUTE</code> <code>Literal</code> <p>Binance 5 minute interval.</p> <code>TF_15MINUTE</code> <code>Literal</code> <p>Binance 15 minute interval.</p> <code>TF_30MINUTE</code> <code>Literal</code> <p>Binance 30 minute interval.</p> <code>TF_1HOUR</code> <code>Literal</code> <p>Binance 1 hour interval.</p> <code>TF_2HOUR</code> <code>Literal</code> <p>Binance 2 hour interval.</p> <code>TF_4HOUR</code> <code>Literal</code> <p>Binance 4 hour interval.</p> <code>TF_6HOUR</code> <code>Literal</code> <p>Binance 6 hour interval.</p> <code>TF_8HOUR</code> <code>Literal</code> <p>Binance 8 hour interval.</p> <code>TF_12HOUR</code> <code>Literal</code> <p>Binance 12 hour interval.</p> <code>TF_1DAY</code> <code>Literal</code> <p>Binance 1 day interval.</p> <code>TF_3DAY</code> <code>Literal</code> <p>Binance 3 day interval.</p> <code>TF_1WEEK</code> <code>Literal</code> <p>Binance 1 week interval.</p> <code>TF_1MONTH</code> <code>Literal</code> <p>Binance 1 month interval.</p>"},{"location":"reference/tradingtoolbox/exchanges/okx/","title":"Okx","text":""},{"location":"reference/tradingtoolbox/exchanges/okx/#tradingtoolbox.exchanges.okx.OKXKlines","title":"<code>OKXKlines</code>","text":"<p>A class that helps downloading klines from OKX.</p> Usage <pre><code>from tradingtoolbox.exchanges import OKXKlines\n\n\nklines = OKXKlines()\ndf = klines.load_klines(\n    \"PEPE-USDT-SWAP\", \"1m\", days_ago=30\n)\n</code></pre>"},{"location":"reference/tradingtoolbox/exchanges/okx/#tradingtoolbox.exchanges.okx.OKXKlines.load_klines","title":"<code>load_klines(instrument, tf, days_ago=1, end=datetime.now())</code>","text":"<p>Load klines from the past X days. OKX's api is limited in to a max of 100 items. This method, will loop until it finds the amount needed</p> <p>Parameters:</p> Name Type Description Default <code>instrument</code> <code>str</code> <p>The instrument to fetch</p> required <code>tf</code> <code>str</code> <p>The timeframe to fetch</p> required <code>days_ago</code> <code>int</code> <p>The number of days ago to look at</p> <code>1</code> <code>end</code> <p>The end date</p> <code>now()</code> Source code in <code>src/tradingtoolbox/exchanges/okx.py</code> <pre><code>def load_klines(\n    self, instrument: str, tf: str, days_ago: int = 1, end=datetime.now()\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Load klines from the past X days.\n    OKX's api is limited in to a max of 100 items. This method, will loop until it finds the amount needed\n\n    Parameters:\n        instrument: The instrument to fetch\n        tf: The timeframe to fetch\n        days_ago: The number of days ago to look at\n        end: The end date\n    \"\"\"\n    df = self._find_kline_file(instrument, tf)\n\n    if df is None:\n        df = self._fetch_lines(instrument, tf, None)\n\n    start_date = end - pd.Timedelta(days=days_ago)\n    while start_date.timestamp() &lt; df[\"date\"].min():  # type: ignore\n        new_df = self._fetch_lines(instrument, tf, df[\"date\"].min())\n        df = pd.concat([df, new_df])\n        df[\"d\"] = pd.to_datetime(df[\"date\"], unit=\"ms\")\n        name = self._get_kline_file_name(instrument, tf)\n        print(name)\n        df.to_parquet(self._get_kline_file_name(instrument, tf))\n        time.sleep(0.1)\n        print(df)\n\n    df = df.sort_values(by=[\"date\"], ascending=True)\n    df[\"date\"] = pd.to_datetime(df[\"date\"], unit=\"ms\")\n    return df\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/__init__/","title":"Utils","text":"<p>A bunch of util functions</p>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.Cache","title":"<code>Cache</code>","text":"<p>               Bases: <code>Struct</code></p> <p>Cache class for handling file-based caching with support for asynchronous data loading.</p> <p>Attributes:</p> Name Type Description <code>cache_path</code> <code>str</code> <p>The path where the cache file is stored.</p> <code>method</code> <code>Optional[Callable]</code> <p>A callable, typically an async method, to fetch data when the cache doesn't exist or needs to be reloaded.</p> <code>date_as_suffix</code> <code>bool</code> <p>If True, appends today's date to the cache file name as a suffix.</p> <p>Methods:</p> Name Description <code>get_async</code> <p>Asynchronously retrieves data from the cache. If the cache file doesn't exist, it will fetch data using the provided method and store it in the cache.</p> <code>clean_cache</code> <p>Deletes the cache file from disk.</p> <p>Usage: <pre><code>async def my_function():\n    await asyncio.sleep(5)\n    return []\n\ncache = Cache(\n    cache_path=f\"./cache/markets_{ex.exchange_name}.json\", method=ex.get_contracts\n)\ndata = await cache.get_async()\n\n# Use this if you don't have any other async.io task, otherwise the program will end before `my_function` runs\nawait cache.wait_till_complete()\n</code></pre></p>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.Cache.cache_path","title":"<code>cache_path: str</code>","text":"<p>Where you want the file to be stored</p>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.Cache.date_as_suffix","title":"<code>date_as_suffix: bool = True</code>","text":"<p>If true, will append today's date to the cache file.</p>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.Cache.method","title":"<code>method: Optional[Callable] = None</code>","text":"<p>A lambda method to run in case the file doesn't exist</p>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.Cache.clean_cache","title":"<code>clean_cache()</code>","text":"<p>Removes the cache file.</p> Source code in <code>src/tradingtoolbox/utils/cache.py</code> <pre><code>def clean_cache(self):\n    \"\"\"\n    Removes the cache file.\n    \"\"\"\n    if os.path.exists(self.cache_path):\n        os.remove(self.cache_path)\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.Cache.get_async","title":"<code>get_async(reload=True)</code>","text":"<p>Gets the data from the cache. If it doesn't exist, it will reload it.</p> <p>Parameters:</p> Name Type Description Default <code>reload</code> <code>bool</code> <p>Whether to reload the data. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The data from the cache.</p> Source code in <code>src/tradingtoolbox/utils/cache.py</code> <pre><code>async def get_async(self, reload=True) -&gt; dict:\n    \"\"\"\n    Gets the data from the cache. If it doesn't exist, it will reload it.\n\n    Args:\n        reload (bool, optional): Whether to reload the data. Defaults to True.\n\n    Returns:\n        dict: The data from the cache.\n    \"\"\"\n    data = self._read_file()\n    if data:\n        if reload:\n            self._task = asyncio.create_task(self._reload_async())\n    else:\n        await self._reload_async()\n        data = self._read_file()\n    return data  # type: ignore\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.Cache.wait_till_complete","title":"<code>wait_till_complete()</code>","text":"<p>Waits for the task to complete. Use this if you don't have any other async.io task to avoid the program ending before the method is ran</p> Source code in <code>src/tradingtoolbox/utils/cache.py</code> <pre><code>async def wait_till_complete(self):\n    \"\"\"\n    Waits for the task to complete.\n    Use this if you don't have any other async.io task to avoid the program ending before the method is ran\n    \"\"\"\n    if self._task:\n        while True:\n            if self._task.done():\n                break\n            await asyncio.sleep(1)  # Check every second\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.Logger","title":"<code>Logger(suppressed_modules=SUPPRESSED_MODULES, log_dir='./logs')</code>","text":"<p>Custom Logger class utilizing Rich and Loguru for advanced logging.</p> <p>This class sets up a logging system that uses both the <code>Rich</code> library for enhanced output formatting in the console and <code>Loguru</code> for handling log files and more sophisticated logging features. The logger is configured to display colored and detailed logs in the terminal, while also saving structured logs to a file for debugging purposes.</p> <p>Key Features:</p> <ul> <li>Rich Tracebacks: Automatically installs Rich traceback for more readable   error messages in the console, highlighting key information such as line numbers   and functions.</li> <li>Log File Handling: Logs are saved in a specified directory with detailed   information in JSON-like format, serialized for easier parsing.</li> <li>Log Levels: Configured to handle different log levels, focusing on <code>INFO</code>   messages for the console and <code>DEBUG</code> level messages for log files.</li> </ul> <p>Usage Example <pre><code>from tradingtoolbox.utils.logger import logger, Logger\n\n# [Optional] Create a custom logger\ncustom_logger = Logger(supressed_modules=[\"talib\"], log_dir=\"./my_logs\")\n\ntry:\n    # Code that might fail\n    print(a)\nexcept Exception as e:\n    logger.error()\n\nlogger.warning(\"This is a warning message\")\nlogger.info({\"key\": \"value\"})\nlogger.print(\"This replaces the standard print\")\n</code></pre></p> <p>Notes:</p> <ul> <li>The logger's console output is colorized using <code>Rich</code>, and it includes rich tracebacks   for easier debugging.</li> <li>Log files are stored in the <code>log_dir</code> directory, defaulting to <code>./logs</code>.</li> </ul> <p>Initializes the custom logger instance.</p> <p>Parameters:</p> Name Type Description Default <code>suppressed_modules</code> <code>list[str]</code> <p>A list of modules to suppress from rich traceback (default is SUPPRESSED_MODULES).</p> <code>SUPPRESSED_MODULES</code> <code>log_dir</code> <code>str</code> <p>The directory where log files will be saved (default is \"./logs\").</p> <code>'./logs'</code> Source code in <code>src/tradingtoolbox/utils/logger.py</code> <pre><code>def __init__(\n    self,\n    suppressed_modules: list[str] = SUPPRESSED_MODULES,\n    log_dir: str = \"./logs\",\n):\n    \"\"\"\n    Initializes the custom logger instance.\n\n    Parameters:\n        suppressed_modules:\n            A list of modules to suppress from rich traceback (default is SUPPRESSED_MODULES).\n        log_dir:\n            The directory where log files will be saved (default is \"./logs\").\n    \"\"\"\n\n    self._create_logs_dir(log_dir)\n\n    # This will install rich to traceback, which is quite handy\n    rich.traceback.install(\n        show_locals=False,\n        suppress=[__import__(name) for name in suppressed_modules],\n    )\n\n    config = {\n        \"handlers\": [\n            {\n                \"sink\": RichHandler(\n                    show_level=False,\n                    show_time=True,\n                    rich_tracebacks=True,\n                    markup=True,\n                    omit_repeated_times=False,\n                ),\n                # \"sink\": sys.stdout,\n                # This will force us to only use the rich handler on normal levels\n                \"filter\": lambda record: record[\"level\"].name == \"INFO\",\n                \"format\": \"{message}\",\n            },\n            # {\n            #     \"sink\": sys.stdout,\n            #     \"colorize\": True,\n            #     \"backtrace\": True,\n            #     \"diagnose\": True,\n            #     \"enqueue\": False,\n            #     \"format\": \"&lt;cyan&gt;\u276f {module}:{function} ({line})&lt;/cyan&gt; | &lt;green&gt;{time:YYYY-MM-DD at HH:mm:ss.sss}&lt;/green&gt;\",\n            #     \"filter\": lambda record: record[\"level\"].name == \"INFO\",\n            # },\n            {\n                \"sink\": \"./logs/logs.log\",\n                \"level\": \"DEBUG\",\n                \"serialize\": True,\n                \"enqueue\": True,\n                \"colorize\": True,\n                \"format\": \"&lt;light-cyan&gt;\u276f {module}:{function} ({line})&lt;/light-cyan&gt; | &lt;light-black&gt;{time:YYYY-MM-DD at HH:mm:ss.sss}&lt;/light-black&gt;\\n{message}\",\n            },\n        ],\n    }\n\n    _logger.configure(**config)  # type: ignore\n    self.logger = _logger.patch(patching)\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.Logger.error","title":"<code>error()</code>","text":"<p>Logs the most recent traceback error in a readable format, useful for. Uses the ERROR level</p> Source code in <code>src/tradingtoolbox/utils/logger.py</code> <pre><code>def error(self):\n    \"\"\"\n    Logs the most recent traceback error in a readable format, useful for. Uses the ERROR level\n    \"\"\"\n    console.print(Traceback())\n    recent_traceback = traceback.format_exc(limit=10)\n    self.logger.error(recent_traceback)\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.Logger.info","title":"<code>info(*obj)</code>","text":"<p>Logs an informational message, replacing the standard print function. Uses the INFO level</p> Source code in <code>src/tradingtoolbox/utils/logger.py</code> <pre><code>def info(self, *obj):\n    \"\"\"\n    Logs an informational message, replacing the standard print function. Uses the INFO level\n    \"\"\"\n    for item in obj:\n        self.logger.opt(depth=2).info(pretty_repr(item))\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.Logger.warning","title":"<code>warning(obj)</code>","text":"<p>Logs a warning message with the option to pretty-print an object. Uses the WARNING level</p> Source code in <code>src/tradingtoolbox/utils/logger.py</code> <pre><code>def warning(self, obj):\n    \"\"\"\n    Logs a warning message with the option to pretty-print an object. Uses the WARNING level\n    \"\"\"\n    self.logger.opt(depth=2).warning(pretty_repr(obj))\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/__init__/#tradingtoolbox.utils.print","title":"<code>print(*msg)</code>","text":"<p>Logs the provided object using an advanced logging mechanism.</p> <p>This method overrides the default <code>print</code> function to utilize a logger for output. It ensures that all output is captured through the logging system rather than standard output.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>Any</code> <p>The object to be logged. It can be of any type that the logger can handle, including strings, numbers, or custom objects.</p> <code>()</code> <p>Usage Example <pre><code>from tradingtoolbox.utils.logger import print\n\nprint(\"Hello world\")\n</code></pre></p> Source code in <code>src/tradingtoolbox/utils/logger.py</code> <pre><code>def print(*msg: Any) -&gt; None:\n    \"\"\"\n    Logs the provided object using an advanced logging mechanism.\n\n    This method overrides the default `print` function to utilize a\n    logger for output. It ensures that all output is captured\n    through the logging system rather than standard output.\n\n    Parameters:\n        msg: The object to be logged. It can be of any type that the\n            logger can handle, including strings, numbers, or custom objects.\n\n\n    **Usage Example**\n    ```python\n    from tradingtoolbox.utils.logger import print\n\n    print(\"Hello world\")\n    ```\n    \"\"\"\n    logger.info(*msg)\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/cache/","title":"Cache","text":""},{"location":"reference/tradingtoolbox/utils/cache/#tradingtoolbox.utils.cache.Cache","title":"<code>Cache</code>","text":"<p>               Bases: <code>Struct</code></p> <p>Cache class for handling file-based caching with support for asynchronous data loading.</p> <p>Attributes:</p> Name Type Description <code>cache_path</code> <code>str</code> <p>The path where the cache file is stored.</p> <code>method</code> <code>Optional[Callable]</code> <p>A callable, typically an async method, to fetch data when the cache doesn't exist or needs to be reloaded.</p> <code>date_as_suffix</code> <code>bool</code> <p>If True, appends today's date to the cache file name as a suffix.</p> <p>Methods:</p> Name Description <code>get_async</code> <p>Asynchronously retrieves data from the cache. If the cache file doesn't exist, it will fetch data using the provided method and store it in the cache.</p> <code>clean_cache</code> <p>Deletes the cache file from disk.</p> <p>Usage: <pre><code>async def my_function():\n    await asyncio.sleep(5)\n    return []\n\ncache = Cache(\n    cache_path=f\"./cache/markets_{ex.exchange_name}.json\", method=ex.get_contracts\n)\ndata = await cache.get_async()\n\n# Use this if you don't have any other async.io task, otherwise the program will end before `my_function` runs\nawait cache.wait_till_complete()\n</code></pre></p>"},{"location":"reference/tradingtoolbox/utils/cache/#tradingtoolbox.utils.cache.Cache.cache_path","title":"<code>cache_path: str</code>","text":"<p>Where you want the file to be stored</p>"},{"location":"reference/tradingtoolbox/utils/cache/#tradingtoolbox.utils.cache.Cache.date_as_suffix","title":"<code>date_as_suffix: bool = True</code>","text":"<p>If true, will append today's date to the cache file.</p>"},{"location":"reference/tradingtoolbox/utils/cache/#tradingtoolbox.utils.cache.Cache.method","title":"<code>method: Optional[Callable] = None</code>","text":"<p>A lambda method to run in case the file doesn't exist</p>"},{"location":"reference/tradingtoolbox/utils/cache/#tradingtoolbox.utils.cache.Cache.clean_cache","title":"<code>clean_cache()</code>","text":"<p>Removes the cache file.</p> Source code in <code>src/tradingtoolbox/utils/cache.py</code> <pre><code>def clean_cache(self):\n    \"\"\"\n    Removes the cache file.\n    \"\"\"\n    if os.path.exists(self.cache_path):\n        os.remove(self.cache_path)\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/cache/#tradingtoolbox.utils.cache.Cache.get_async","title":"<code>get_async(reload=True)</code>","text":"<p>Gets the data from the cache. If it doesn't exist, it will reload it.</p> <p>Parameters:</p> Name Type Description Default <code>reload</code> <code>bool</code> <p>Whether to reload the data. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The data from the cache.</p> Source code in <code>src/tradingtoolbox/utils/cache.py</code> <pre><code>async def get_async(self, reload=True) -&gt; dict:\n    \"\"\"\n    Gets the data from the cache. If it doesn't exist, it will reload it.\n\n    Args:\n        reload (bool, optional): Whether to reload the data. Defaults to True.\n\n    Returns:\n        dict: The data from the cache.\n    \"\"\"\n    data = self._read_file()\n    if data:\n        if reload:\n            self._task = asyncio.create_task(self._reload_async())\n    else:\n        await self._reload_async()\n        data = self._read_file()\n    return data  # type: ignore\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/cache/#tradingtoolbox.utils.cache.Cache.wait_till_complete","title":"<code>wait_till_complete()</code>","text":"<p>Waits for the task to complete. Use this if you don't have any other async.io task to avoid the program ending before the method is ran</p> Source code in <code>src/tradingtoolbox/utils/cache.py</code> <pre><code>async def wait_till_complete(self):\n    \"\"\"\n    Waits for the task to complete.\n    Use this if you don't have any other async.io task to avoid the program ending before the method is ran\n    \"\"\"\n    if self._task:\n        while True:\n            if self._task.done():\n                break\n            await asyncio.sleep(1)  # Check every second\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/logger/","title":"Logger","text":""},{"location":"reference/tradingtoolbox/utils/logger/#tradingtoolbox.utils.logger.logger","title":"<code>logger = Logger()</code>","text":"<p>An instantiated logger that you can use directly</p>"},{"location":"reference/tradingtoolbox/utils/logger/#tradingtoolbox.utils.logger.Logger","title":"<code>Logger(suppressed_modules=SUPPRESSED_MODULES, log_dir='./logs')</code>","text":"<p>Custom Logger class utilizing Rich and Loguru for advanced logging.</p> <p>This class sets up a logging system that uses both the <code>Rich</code> library for enhanced output formatting in the console and <code>Loguru</code> for handling log files and more sophisticated logging features. The logger is configured to display colored and detailed logs in the terminal, while also saving structured logs to a file for debugging purposes.</p> <p>Key Features:</p> <ul> <li>Rich Tracebacks: Automatically installs Rich traceback for more readable   error messages in the console, highlighting key information such as line numbers   and functions.</li> <li>Log File Handling: Logs are saved in a specified directory with detailed   information in JSON-like format, serialized for easier parsing.</li> <li>Log Levels: Configured to handle different log levels, focusing on <code>INFO</code>   messages for the console and <code>DEBUG</code> level messages for log files.</li> </ul> <p>Usage Example <pre><code>from tradingtoolbox.utils.logger import logger, Logger\n\n# [Optional] Create a custom logger\ncustom_logger = Logger(supressed_modules=[\"talib\"], log_dir=\"./my_logs\")\n\ntry:\n    # Code that might fail\n    print(a)\nexcept Exception as e:\n    logger.error()\n\nlogger.warning(\"This is a warning message\")\nlogger.info({\"key\": \"value\"})\nlogger.print(\"This replaces the standard print\")\n</code></pre></p> <p>Notes:</p> <ul> <li>The logger's console output is colorized using <code>Rich</code>, and it includes rich tracebacks   for easier debugging.</li> <li>Log files are stored in the <code>log_dir</code> directory, defaulting to <code>./logs</code>.</li> </ul> <p>Initializes the custom logger instance.</p> <p>Parameters:</p> Name Type Description Default <code>suppressed_modules</code> <code>list[str]</code> <p>A list of modules to suppress from rich traceback (default is SUPPRESSED_MODULES).</p> <code>SUPPRESSED_MODULES</code> <code>log_dir</code> <code>str</code> <p>The directory where log files will be saved (default is \"./logs\").</p> <code>'./logs'</code> Source code in <code>src/tradingtoolbox/utils/logger.py</code> <pre><code>def __init__(\n    self,\n    suppressed_modules: list[str] = SUPPRESSED_MODULES,\n    log_dir: str = \"./logs\",\n):\n    \"\"\"\n    Initializes the custom logger instance.\n\n    Parameters:\n        suppressed_modules:\n            A list of modules to suppress from rich traceback (default is SUPPRESSED_MODULES).\n        log_dir:\n            The directory where log files will be saved (default is \"./logs\").\n    \"\"\"\n\n    self._create_logs_dir(log_dir)\n\n    # This will install rich to traceback, which is quite handy\n    rich.traceback.install(\n        show_locals=False,\n        suppress=[__import__(name) for name in suppressed_modules],\n    )\n\n    config = {\n        \"handlers\": [\n            {\n                \"sink\": RichHandler(\n                    show_level=False,\n                    show_time=True,\n                    rich_tracebacks=True,\n                    markup=True,\n                    omit_repeated_times=False,\n                ),\n                # \"sink\": sys.stdout,\n                # This will force us to only use the rich handler on normal levels\n                \"filter\": lambda record: record[\"level\"].name == \"INFO\",\n                \"format\": \"{message}\",\n            },\n            # {\n            #     \"sink\": sys.stdout,\n            #     \"colorize\": True,\n            #     \"backtrace\": True,\n            #     \"diagnose\": True,\n            #     \"enqueue\": False,\n            #     \"format\": \"&lt;cyan&gt;\u276f {module}:{function} ({line})&lt;/cyan&gt; | &lt;green&gt;{time:YYYY-MM-DD at HH:mm:ss.sss}&lt;/green&gt;\",\n            #     \"filter\": lambda record: record[\"level\"].name == \"INFO\",\n            # },\n            {\n                \"sink\": \"./logs/logs.log\",\n                \"level\": \"DEBUG\",\n                \"serialize\": True,\n                \"enqueue\": True,\n                \"colorize\": True,\n                \"format\": \"&lt;light-cyan&gt;\u276f {module}:{function} ({line})&lt;/light-cyan&gt; | &lt;light-black&gt;{time:YYYY-MM-DD at HH:mm:ss.sss}&lt;/light-black&gt;\\n{message}\",\n            },\n        ],\n    }\n\n    _logger.configure(**config)  # type: ignore\n    self.logger = _logger.patch(patching)\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/logger/#tradingtoolbox.utils.logger.Logger.error","title":"<code>error()</code>","text":"<p>Logs the most recent traceback error in a readable format, useful for. Uses the ERROR level</p> Source code in <code>src/tradingtoolbox/utils/logger.py</code> <pre><code>def error(self):\n    \"\"\"\n    Logs the most recent traceback error in a readable format, useful for. Uses the ERROR level\n    \"\"\"\n    console.print(Traceback())\n    recent_traceback = traceback.format_exc(limit=10)\n    self.logger.error(recent_traceback)\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/logger/#tradingtoolbox.utils.logger.Logger.info","title":"<code>info(*obj)</code>","text":"<p>Logs an informational message, replacing the standard print function. Uses the INFO level</p> Source code in <code>src/tradingtoolbox/utils/logger.py</code> <pre><code>def info(self, *obj):\n    \"\"\"\n    Logs an informational message, replacing the standard print function. Uses the INFO level\n    \"\"\"\n    for item in obj:\n        self.logger.opt(depth=2).info(pretty_repr(item))\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/logger/#tradingtoolbox.utils.logger.Logger.warning","title":"<code>warning(obj)</code>","text":"<p>Logs a warning message with the option to pretty-print an object. Uses the WARNING level</p> Source code in <code>src/tradingtoolbox/utils/logger.py</code> <pre><code>def warning(self, obj):\n    \"\"\"\n    Logs a warning message with the option to pretty-print an object. Uses the WARNING level\n    \"\"\"\n    self.logger.opt(depth=2).warning(pretty_repr(obj))\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/logger/#tradingtoolbox.utils.logger.print","title":"<code>print(*msg)</code>","text":"<p>Logs the provided object using an advanced logging mechanism.</p> <p>This method overrides the default <code>print</code> function to utilize a logger for output. It ensures that all output is captured through the logging system rather than standard output.</p> <p>Parameters:</p> Name Type Description Default <code>msg</code> <code>Any</code> <p>The object to be logged. It can be of any type that the logger can handle, including strings, numbers, or custom objects.</p> <code>()</code> <p>Usage Example <pre><code>from tradingtoolbox.utils.logger import print\n\nprint(\"Hello world\")\n</code></pre></p> Source code in <code>src/tradingtoolbox/utils/logger.py</code> <pre><code>def print(*msg: Any) -&gt; None:\n    \"\"\"\n    Logs the provided object using an advanced logging mechanism.\n\n    This method overrides the default `print` function to utilize a\n    logger for output. It ensures that all output is captured\n    through the logging system rather than standard output.\n\n    Parameters:\n        msg: The object to be logged. It can be of any type that the\n            logger can handle, including strings, numbers, or custom objects.\n\n\n    **Usage Example**\n    ```python\n    from tradingtoolbox.utils.logger import print\n\n    print(\"Hello world\")\n    ```\n    \"\"\"\n    logger.info(*msg)\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/resample/","title":"Resample","text":""},{"location":"reference/tradingtoolbox/utils/resample/#tradingtoolbox.utils.resample.Aggregation","title":"<code>Aggregation</code>","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"reference/tradingtoolbox/utils/resample/#tradingtoolbox.utils.resample.Aggregation.close","title":"<code>close: str = Field(default='last')</code>","text":""},{"location":"reference/tradingtoolbox/utils/resample/#tradingtoolbox.utils.resample.Aggregation.high","title":"<code>high: str = Field(default='max')</code>","text":""},{"location":"reference/tradingtoolbox/utils/resample/#tradingtoolbox.utils.resample.Aggregation.low","title":"<code>low: str = Field(default='min')</code>","text":""},{"location":"reference/tradingtoolbox/utils/resample/#tradingtoolbox.utils.resample.Aggregation.open","title":"<code>open: str = Field(default='first')</code>","text":""},{"location":"reference/tradingtoolbox/utils/resample/#tradingtoolbox.utils.resample.Aggregation.volume","title":"<code>volume: str = Field(default='sum')</code>","text":""},{"location":"reference/tradingtoolbox/utils/resample/#tradingtoolbox.utils.resample.resample","title":"<code>resample(df, tf='1H', agg=Aggregation(), on='date')</code>","text":"<p>Resamples a DataFrame over a specified time frequency and applies aggregation functions.</p> <p>This function resamples the input DataFrame <code>df</code> using the time frequency provided by <code>tf</code>. It then applies the specified aggregation functions on the relevant columns and fills any missing values via forward fill.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The DataFrame to be resampled. It must contain a time-based column that can be used for resampling.</p> required <code>tf</code> <code>str</code> <p>The time frequency for resampling, default is \"1H\" (one hour). It should be in a format accepted by pandas' <code>resample()</code> function, such as \"1D\" for daily, \"1T\" for minute, etc.</p> <code>'1H'</code> <code>agg</code> <code>Aggregation</code> <p>A dictionary defining the aggregation method for each relevant column. The default value aggregates the \"open\" column by the first value, \"high\" by the max, \"low\" by the min, \"close\" by the last value, and \"volume\" by the sum.</p> <code>Aggregation()</code> <code>on</code> <code>str</code> <p>The name of the column to be used for resampling, typically a date or timestamp column. The default is \"date\".</p> <code>'date'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A resampled DataFrame with the aggregation applied, missing values dropped, and any remaining missing values forward-filled.</p> <p>Examples:</p> <pre><code>import pandas as pd\n\ndf = pd.DataFrame({\n     \"date\": pd.date_range(start=\"2023-01-01\", periods=5, freq=\"1H\"),\n     \"open\": [100, 101, 102, 103, 104],\n     \"high\": [110, 111, 112, 113, 114],\n     \"low\": [90, 91, 92, 93, 94],\n     \"close\": [105, 106, 107, 108, 109],\n     \"volume\": [1000, 1500, 1200, 1100, 1400]\n })\n resample(df, tf=\"2H\", on=\"date\")\n</code></pre> Source code in <code>src/tradingtoolbox/utils/resample.py</code> <pre><code>def resample(\n    df: pd.DataFrame, tf: str = \"1H\", agg: Aggregation = Aggregation(), on: str = \"date\"\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Resamples a DataFrame over a specified time frequency and applies aggregation functions.\n\n    This function resamples the input DataFrame `df` using the time frequency provided by `tf`.\n    It then applies the specified aggregation functions on the relevant columns and fills any\n    missing values via forward fill.\n\n    Parameters:\n        df: The DataFrame to be resampled. It must contain a time-based column that can be used\n            for resampling.\n        tf: The time frequency for resampling, default is \"1H\" (one hour). It should be in a format\n            accepted by pandas' `resample()` function, such as \"1D\" for daily, \"1T\" for minute, etc.\n        agg: A dictionary defining the aggregation method for each relevant column. The default value\n            aggregates the \"open\" column by the first value, \"high\" by the max, \"low\" by the min,\n            \"close\" by the last value, and \"volume\" by the sum.\n        on: The name of the column to be used for resampling, typically a date or timestamp column.\n            The default is \"date\".\n\n    Returns:\n        A resampled DataFrame with the aggregation applied, missing values dropped, and any remaining missing values forward-filled.\n\n    Examples:\n\n    ```py\n    import pandas as pd\n\n    df = pd.DataFrame({\n         \"date\": pd.date_range(start=\"2023-01-01\", periods=5, freq=\"1H\"),\n         \"open\": [100, 101, 102, 103, 104],\n         \"high\": [110, 111, 112, 113, 114],\n         \"low\": [90, 91, 92, 93, 94],\n         \"close\": [105, 106, 107, 108, 109],\n         \"volume\": [1000, 1500, 1200, 1100, 1400]\n     })\n     resample(df, tf=\"2H\", on=\"date\")\n    ```\n    \"\"\"\n    return df.resample(tf, on=on).agg(agg).dropna(how=\"all\").fillna(method=\"ffill\")  # type: ignore\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/time_manip/","title":"Time manip","text":""},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.time_manip","title":"<code>time_manip = TimeManip()</code>","text":"<p>A TimeManip object instance Usage:     <pre><code>from tradingtoolbox.utils.time_manip import time_manip\n\ndays = time_manip.days_ago(3)\nprint(days)\n\n&gt;&gt;&gt; datetime.datetime(2024, 9, 25, 23, 54, 58, 71997)\n</code></pre></p>"},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip","title":"<code>TimeManip</code>","text":""},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip.convert_datetime_to_ms","title":"<code>convert_datetime_to_ms(df)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to operate onw</p> required Source code in <code>src/tradingtoolbox/utils/time_manip.py</code> <pre><code>def convert_datetime_to_ms(self, df: pd.DataFrame):\n    \"\"\"\n    Parameters:\n        df: The dataframe to operate onw\n    \"\"\"\n    return pd.to_datetime(df).astype(np.int64) // 10**6\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip.convert_datetime_to_s","title":"<code>convert_datetime_to_s(df)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to operate onw</p> required Source code in <code>src/tradingtoolbox/utils/time_manip.py</code> <pre><code>def convert_datetime_to_s(self, df: pd.DataFrame):\n    \"\"\"\n    Parameters:\n        df: The dataframe to operate onw\n    \"\"\"\n    return pd.to_datetime(df).astype(np.int64) // 10**9\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip.convert_duration_to_timestamp","title":"<code>convert_duration_to_timestamp(df, unit='ms')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to operate onw</p> required Source code in <code>src/tradingtoolbox/utils/time_manip.py</code> <pre><code>def convert_duration_to_timestamp(self, df: pd.DataFrame, unit=\"ms\"):\n    \"\"\"\n    Parameters:\n        df: The dataframe to operate onw\n    \"\"\"\n    return pd.to_timedelta(df, unit=unit)\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip.convert_ms_to_datetime","title":"<code>convert_ms_to_datetime(df)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to operate onw</p> required Source code in <code>src/tradingtoolbox/utils/time_manip.py</code> <pre><code>def convert_ms_to_datetime(self, df: pd.DataFrame):\n    \"\"\"\n    Parameters:\n        df: The dataframe to operate onw\n    \"\"\"\n    return pd.to_datetime(df, unit=\"ms\")\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip.convert_s_to_datetime","title":"<code>convert_s_to_datetime(df)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to operate onw</p> required Source code in <code>src/tradingtoolbox/utils/time_manip.py</code> <pre><code>def convert_s_to_datetime(self, df: pd.DataFrame):\n    \"\"\"\n    Parameters:\n        df: The dataframe to operate onw\n    \"\"\"\n    return pd.to_datetime(df, unit=\"s\")\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip.days_ago","title":"<code>days_ago(days=0, to_timestamp=False)</code>","text":"<p>Return X days ago</p> <p>Parameters:</p> Name Type Description Default <code>days</code> <p>The number of days ago you want to return</p> <code>0</code> <code>to_timestamp</code> <p>weather to return a timestamp or not</p> <code>False</code> Source code in <code>src/tradingtoolbox/utils/time_manip.py</code> <pre><code>def days_ago(self, days=0, to_timestamp=False):\n    \"\"\"\n    Return X days ago\n\n    Parameters:\n        days: The number of days ago you want to return\n        to_timestamp: weather to return a timestamp or not\n    \"\"\"\n    today = datetime.now()\n    date = today - timedelta(days=days)\n    if to_timestamp:\n        return date.timestamp()\n    return date\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip.hours_ago","title":"<code>hours_ago(hours=0, to_timestamp=False)</code>","text":"<p>Return X hours ago</p> <p>Parameters:</p> Name Type Description Default <code>hours</code> <p>The number of hours ago you want to return</p> <code>0</code> <code>to_timestamp</code> <p>weather to return a timestamp or not</p> <code>False</code> Source code in <code>src/tradingtoolbox/utils/time_manip.py</code> <pre><code>def hours_ago(self, hours=0, to_timestamp=False):\n    \"\"\"\n    Return X hours ago\n\n    Parameters:\n        hours: The number of hours ago you want to return\n        to_timestamp: weather to return a timestamp or not\n    \"\"\"\n    today = datetime.now()\n    date = today - timedelta(hours=hours)\n    if to_timestamp:\n        return date.timestamp()\n    return date\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip.months_ago","title":"<code>months_ago(months=0, to_timestamp=False)</code>","text":"<p>Return X months ago</p> <p>Parameters:</p> Name Type Description Default <code>months</code> <p>The number of months ago you want to return</p> <code>0</code> <code>to_timestamp</code> <p>weather to return a timestamp or not</p> <code>False</code> Source code in <code>src/tradingtoolbox/utils/time_manip.py</code> <pre><code>def months_ago(self, months=0, to_timestamp=False):\n    \"\"\"\n    Return X months ago\n\n    Parameters:\n        months: The number of months ago you want to return\n        to_timestamp: weather to return a timestamp or not\n    \"\"\"\n    today = datetime.now()\n    date = today - relativedelta(months=months)\n    if to_timestamp:\n        return date.timestamp()\n    return date\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip.pd_days_ago","title":"<code>pd_days_ago(df, days=0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to operate onw</p> required <code>days</code> <p>The number of days ago</p> <code>0</code> Source code in <code>src/tradingtoolbox/utils/time_manip.py</code> <pre><code>def pd_days_ago(self, df: pd.DataFrame, days=0):\n    \"\"\"\n    Parameters:\n        df: The dataframe to operate onw\n        days: The number of days ago\n    \"\"\"\n    today = df.index.values[-1]\n    months_ago = today - pd.DateOffset(days=days)\n\n    return df[df.index &gt;= months_ago]\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip.pd_hours_ago","title":"<code>pd_hours_ago(df, hours=0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to operate onw</p> required <code>hours</code> <p>The number of hours ago</p> <code>0</code> Source code in <code>src/tradingtoolbox/utils/time_manip.py</code> <pre><code>def pd_hours_ago(self, df: pd.DataFrame, hours=0):\n    \"\"\"\n    Parameters:\n        df: The dataframe to operate onw\n        hours: The number of hours ago\n    \"\"\"\n    today = df.index.values[-1]\n    hours_ago = today - pd.DateOffset(hours=hours)\n\n    return df[df.index &gt;= hours_ago]\n</code></pre>"},{"location":"reference/tradingtoolbox/utils/time_manip/#tradingtoolbox.utils.time_manip.TimeManip.pd_months_ago","title":"<code>pd_months_ago(df, months=0)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>The dataframe to operate onw</p> required <code>months</code> <p>The number of months ago</p> <code>0</code> Source code in <code>src/tradingtoolbox/utils/time_manip.py</code> <pre><code>def pd_months_ago(self, df: pd.DataFrame, months=0):\n    \"\"\"\n    Parameters:\n        df: The dataframe to operate onw\n        months: The number of months ago\n    \"\"\"\n    today = df.index.values[-1]\n    months_ago = today - pd.DateOffset(months=months)\n\n    return df[df.index &gt;= months_ago]\n</code></pre>"}]}